<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta
            name="viewport"
            content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
        />
        <title>Dice</title>

        <!-- PWA Meta Tags -->
        <link rel="manifest" href="/manifest.json" />
        <link rel="icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/svg+xml" href="/icon.svg" />
        <meta
            name="theme-color"
            content="#ffffff"
            media="(prefers-color-scheme: light)"
        />
        <meta
            name="theme-color"
            content="#000000"
            media="(prefers-color-scheme: dark)"
        />
        <meta name="apple-mobile-web-app-capable" content="yes" />
        <meta name="apple-mobile-web-app-status-bar-style" content="default" />
        <meta name="apple-mobile-web-app-title" content="Dice" />
        <link rel="apple-touch-icon" href="/icon-192.png" />

        <style>
            body {
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                height: 100dvh;
                margin: 0;
                gap: 1rem;
                touch-action: manipulation;
                background-color: white;
                color: black;
                font-family:
                    -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
                    Oxygen, Ubuntu, Cantarell, sans-serif;
            }

            @media (prefers-color-scheme: dark) {
                body {
                    background-color: black;
                    color: white;
                }
            }
            #update-notification {
                position: fixed;
                top: 1rem;
                left: 50%;
                transform: translateX(-50%);
                background-color: #4caf50;
                color: white;
                padding: 1rem 2rem;
                border-radius: 0.5rem;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
                display: none;
                z-index: 1000;
                font-size: 1rem;
                cursor: pointer;
                touch-action: manipulation;
            }
            #update-notification.show {
                display: block;
            }
            #dice {
                flex: 3;
                display: grid;
                align-items: center;
                justify-content: center;
                align-content: center;
                font-size: min(30vh, 30vw);
                gap: 1vh;
                width: 100%;
            }
            #dice span {
                transition: opacity 0.1s ease-in-out;
            }
            #actions {
                flex: 1;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 2vh;
            }
            button {
                padding: 2vh 4vh;
                font-size: min(10vh, 8vw);
                cursor: pointer;
                touch-action: manipulation;
                transition: opacity 0.1s ease-in-out;
            }
            button:disabled {
                opacity: 0.5;
                cursor: not-allowed;
            }
            #minus-button,
            #plus-button {
                width: min(15vh, 20vw);
            }
        </style>
    </head>
    <body>
        <div id="update-notification">Update available! Tap to refresh.</div>
        <div id="dice">?</div>
        <div id="actions">
            <button id="minus-button">-</button>
            <button id="roll-button">Roll</button>
            <button id="plus-button">+</button>
        </div>
    </body>
    <script>
        const FACES = ["⚀", "⚁", "⚂", "⚃", "⚄", "⚅"];
        const dice = document.getElementById("dice");
        const rollButton = document.getElementById("roll-button");
        const minusButton = document.getElementById("minus-button");
        const plusButton = document.getElementById("plus-button");

        let diceCount = 1;
        let isRolling = false;

        // Use crypto.getRandomValues for better randomness
        function getRandomDiceValue() {
            const array = new Uint32Array(1);
            crypto.getRandomValues(array);
            return array[0] % FACES.length;
        }

        async function rollDice() {
            if (isRolling) return;

            isRolling = true;
            rollButton.disabled = true;
            minusButton.disabled = true;
            plusButton.disabled = true;

            // Calculate grid dimensions
            const cols = Math.ceil(Math.sqrt(diceCount));
            const rows = Math.ceil(diceCount / cols);

            dice.style.gridTemplateColumns = `repeat(${cols}, auto)`;
            dice.style.gridTemplateRows = `repeat(${rows}, auto)`;

            // Get existing dice elements or create new ones
            let diceElements = dice.querySelectorAll("span");

            // If dice count changed, rebuild the grid
            if (diceElements.length !== diceCount) {
                const spans = [];
                for (let i = 0; i < diceCount; i++) {
                    const randomNumber = getRandomDiceValue();
                    spans.push(`<span>${FACES[randomNumber]}</span>`);
                }
                dice.innerHTML = spans.join("");
                diceElements = dice.querySelectorAll("span");
            }

            const totalAnimationTime = 200; // 0.2 seconds
            const staggerDelay = totalAnimationTime / diceCount;

            // Set all dice to 50% opacity before rolling
            for (let i = 0; i < diceCount; i++) {
                diceElements[i].style.opacity = "0.5";
            }

            // Roll each die with a stagger
            for (let i = 0; i < diceCount; i++) {
                await new Promise((resolve) =>
                    setTimeout(resolve, staggerDelay),
                );
                const randomNumber = getRandomDiceValue();
                diceElements[i].textContent = FACES[randomNumber];
                diceElements[i].style.opacity = "1";
            }

            isRolling = false;
            updateButtons();
        }

        function updateButtons() {
            if (!isRolling) {
                rollButton.disabled = false;
                minusButton.disabled = diceCount <= 1;
                plusButton.disabled = diceCount >= 6;
            }
        }

        rollButton.addEventListener("click", () => {
            rollDice();
        });

        minusButton.addEventListener("click", () => {
            if (diceCount > 1) {
                diceCount--;
                rollDice();
            }
        });

        plusButton.addEventListener("click", () => {
            if (diceCount < 6) {
                diceCount++;
                rollDice();
            }
        });

        updateButtons();
        rollDice();

        // Register Service Worker for PWA with auto-update support
        if ("serviceWorker" in navigator) {
            let refreshing = false;

            // Reload page when new service worker takes over
            navigator.serviceWorker.addEventListener("controllerchange", () => {
                if (!refreshing) {
                    refreshing = true;
                    window.location.reload();
                }
            });

            window.addEventListener("load", () => {
                navigator.serviceWorker
                    .register("/sw.js")
                    .then((registration) => {
                        console.log("Service Worker registered:", registration);

                        // Check for updates every time the page loads
                        registration.update();

                        // Check for updates periodically (every hour)
                        setInterval(
                            () => {
                                registration.update();
                            },
                            60 * 60 * 1000,
                        );

                        // Handle waiting service worker
                        const showUpdateNotification = () => {
                            const notification = document.getElementById(
                                "update-notification",
                            );
                            notification.classList.add("show");
                            notification.addEventListener("click", () => {
                                if (registration.waiting) {
                                    registration.waiting.postMessage({
                                        type: "SKIP_WAITING",
                                    });
                                }
                            });
                        };

                        // Check if there's already a waiting service worker
                        if (registration.waiting) {
                            showUpdateNotification();
                        }

                        // Listen for new service worker waiting
                        registration.addEventListener("updatefound", () => {
                            const newWorker = registration.installing;
                            if (newWorker) {
                                newWorker.addEventListener(
                                    "statechange",
                                    () => {
                                        if (
                                            newWorker.state === "installed" &&
                                            navigator.serviceWorker.controller
                                        ) {
                                            showUpdateNotification();
                                        }
                                    },
                                );
                            }
                        });
                    })
                    .catch((error) => {
                        console.log(
                            "Service Worker registration failed:",
                            error,
                        );
                    });
            });
        }
    </script>
</html>
